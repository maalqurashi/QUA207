<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Frequency Polygon</title>
    <!-- Tailwind CSS CDN for basic styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsDelivr CDN for Saudi Riyal Font -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@emran-alhaddad/saudi-riyal-font/index.css">
    <style>
        body {
            font-family: Arial, sans-serif; /* Changed font to Arial */
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            text-align: center;
        }
        canvas {
            background-color: #e2e8f0; /* Lighter blue-gray for canvas */
            border-radius: 10px;
            border: 1px solid #cbd5e1;
            margin-top: 20px;
            touch-action: none; /* Disable default touch actions like scrolling/zooming */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            margin-bottom: 10px; /* Reduced margin to make space for Q1 */
        }
        th, td {
            border: 1px solid #e2e8f0;
            padding: 12px;
            text-align: center;
        }
        th {
            background-color: #4a5568; /* Darker gray for table header */
            color: #ffffff;
            font-weight: 600;
        }
        td {
            background-color: #f7fafc; /* Very light gray for table cells */
        }
        .message-box {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
            display: none; /* Hidden by default */
        }
        .message-box.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .message-box.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .button-group button {
            transition: all 0.2s ease-in-out;
            border-radius: 8px;
            padding: 12px 25px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.1);
            background: linear-gradient(145deg, #60a5fa, #3b82f6);
            color: white;
            border: none;
        }
        .button-group button:hover {
            transform: translateY(-2px);
            box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(145deg, #4f8cf4, #3366cc);
        }
        .button-group button:active {
            transform: translateY(0);
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        .button-group button#resetButton {
            background: linear-gradient(145deg, #a0aec0, #718096);
        }
        .button-group button#resetButton:hover {
            background: linear-gradient(145deg, #8b96a9, #5c6776);
        }
        .table-caption {
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #555;
            white-space: nowrap; /* Ensure caption stays on one line */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
        }
        .scenario-text {
            text-align: left;
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.6;
            color: #333;
        }
        .question-text {
            text-align: left;
            margin-top: 15px;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
        }
        .answer-feedback {
            font-weight: normal;
            margin-left: 15px;
            margin-top: 5px;
            font-size: 0.95em;
        }
        .text-green-600 { color: #22c55e; } /* Tailwind green-600 */
        .text-red-600 { color: #ef4444; }   /* Tailwind red-600 */
        .text-yellow-600 { color: #eab308; } /* Tailwind yellow-600 */

        .question-item {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 15px !important;
        }
        .question-item:last-child {
            border-bottom: none;
            margin-bottom: 0 !important;
        }
        .options-group {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .options-group div {
            margin-bottom: 5px;
        }
        .check-question-button {
            transition: all 0.2s ease-in-out;
            border-radius: 8px;
            padding: 12px 25px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.1);
            background: linear-gradient(145deg, #60a5fa, #3b82f6); /* Matched main button color */
            color: white;
            border: none;
        }
        .check-question-button:hover {
            transform: translateY(-2px);
            box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(145deg, #4f8cf4, #3366cc); /* Matched main button hover */
        }
        .check-question-button:active {
            transform: translateY(0);
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        /* The font-family for icon-saudi_riyal is defined in the CDN stylesheet */
        .icon-saudi_riyal {
            font-size: inherit;
            color: inherit;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-5">
    <div class="container bg-white rounded-xl shadow-2xl p-8 md:p-10">
        <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800 mb-4">Interactive Frequency Polygon Activity</h1>
        <p class="text-gray-600 mb-6 text-lg">
            
        </p>

        <div class="scenario-text">
            A local business recorded its monthly sales revenue (in thousands of <span class="icon-saudi_riyal"></span>) over a period. The revenue figures are grouped into specific ranges, and the frequency for each range indicates how many months achieved revenue within that bracket. Your task is to accurately represent this data in the frequency polygon below.
        </div>

        <div class="table-caption">
            Table 1: Frequency Distribution of Monthly Sales Revenue
        </div>
        <table class="min-w-full bg-white rounded-lg overflow-hidden shadow-md mb-8">
            <thead>
                <tr>
                    <th>Sales Revenue (in thousands)</th>
                    <th>Frequency</th>
                </tr>
            </thead>
            <tbody id="dataTableBody">
                <!-- Table rows will be generated dynamically by JavaScript -->
            </tbody>
        </table>

        <div class="question-text">
            Q1: Drag each point on the frequency polygon to match the frequency given in the Table 1.
        </div>

        <canvas id="histogramCanvas" class="w-full h-auto block mx-auto" onselectstart="return false;"></canvas>

        <div class="message-box" id="messageBox"></div>

        <div class="button-group mt-8 flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4">
            <button id="checkButton" class="bg-blue-600 hover:bg-blue-700 text-white">
                Check My Work (Frequency Polygon)
            </button>
            <button id="resetButton" class="bg-gray-400 hover:bg-gray-500 text-white">
                Reset Frequency Polygon
            </button>
        </div>

        <!-- New Questions Section -->
        <div class="question-section mt-8 text-left">
            <div class="question-item">
                <p class="question-text">Q2: Which sales revenue range (in thousands of <span class="icon-saudi_riyal"></span>) had the highest frequency of months?</p>
                <div class="options-group" id="q2Options"></div>
                <button class="check-question-button" data-question="q2">Check Answer</button>
                <p class="answer-feedback" id="q2Feedback"></p>
            </div>
            <div class="question-item">
                <p class="question-text">Q3: How many months had sales revenue less than <span class="icon-saudi_riyal"></span> <span id="q3Score"></span> thousand ?</p>
                <div class="options-group" id="q3Options"></div>
                <button class="check-question-button" data-question="q3">Check Answer</button>
                <p class="answer-feedback" id="q3Feedback"></p>
            </div>
            <div class="question-item">
                <p class="question-text">Q4: How many months had sales revenue of at least <span class="icon-saudi_riyal"></span> <span id="q4Score"></span> thousand ?</p>
                <div class="options-group" id="q4Options"></div>
                <button class="check-question-button" data-question="q4">Check Answer</button>
                <p class="answer-feedback" id="q4Feedback"></p>
            </div>
            <div class="question-item">
                <p class="question-text">Q5: What is the percentage of months with sales revenue in the interval <span id="q5Interval"></span> (in thousands of <span class="icon-saudi_riyal"></span>)?</p>
                <div class="options-group" id="q5Options"></div>
                <button class="check-question-button" data-question="q5">Check Answer</button>
                <p class="answer-feedback" id="q5Feedback"></p>
            </div>
        </div>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('histogramCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const dataTableBody = document.getElementById('dataTableBody');

        // Define the histogram data. This will be dynamically generated.
        let histogramData = [];

        // Global variables for canvas dimensions and padding
        const padding = { top: 40, right: 40, bottom: 60, left: 60 };
        let plotAreaWidth;
        let plotAreaHeight;
        let intervalPixelWidth; // Represents the pixel width of one class interval on the plot
        let maxFrequency;
        let frequencyScale;
        const dragTolerance = 15; // Increased tolerance for dragging points
        const pointRadius = 6; // Radius of the draggable points

        // Dragging state variables
        let isDragging = false;
        let draggedPointIndex = -1; // Index in the full points array (including start/end 0s)
        let hoveredPointIndex = -1;

        // Global object to store question data (options, correct answers)
        let questionsData = {
            q2: { question: "Which sales revenue range (in thousands of <span class=\"icon-saudi_riyal\"></span>) had the highest frequency of months?", options: [], correctAnswer: "" },
            q3: { question: "", options: [], correctAnswer: 0, targetScore: 0 },
            q4: { question: "", options: [], correctAnswer: 0, targetScore: 0 },
            q5: { question: "", options: [], correctAnswer: 0, targetIntervalLabel: "" }
        };

        // Helper to shuffle an array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Helper to generate a distractor that is near the correct answer but not equal
        function generateNumericalDistractor(correctAnswer, range, exclude = []) {
            let distractor;
            let attempts = 0;
            do {
                distractor = correctAnswer + (Math.random() * range * 2 - range); // +/- range
                distractor = Math.round(distractor);
                attempts++;
                // Ensure distractor is not in exclude list and is non-negative
                if (attempts > 100) { // Prevent infinite loops
                    distractor = correctAnswer + (correctAnswer > 0 ? -1 : 1); // Fallback to +/- 1
                    break;
                }
            } while (exclude.includes(distractor) || distractor < 0);
            return distractor;
        }

        // Helper to generate a percentage distractor
        function generatePercentageDistractor(correctAnswer, exclude = []) {
            let distractor;
            let attempts = 0;
            do {
                distractor = (correctAnswer + (Math.random() * 20 - 10)).toFixed(2); // +/- 10%
                distractor = parseFloat(distractor);
                attempts++;
                if (attempts > 100) { // Prevent infinite loops
                    distractor = (correctAnswer + (correctAnswer > 0 ? -1 : 1)).toFixed(2); // Fallback to +/- 1
                    distractor = parseFloat(distractor);
                    break;
                }
            } while (exclude.includes(distractor) || distractor < 0 || distractor > 100);
            return distractor;
        }

        /**
         * Generates random data for the frequency polygon and prepares question options.
         */
        function generateRandomData() {
            const numberOfClasses = 4;
            const classWidth = 10;
            const firstClassStart = Math.floor(Math.random() * (70 - 50 + 1)) + 50;
            const newData = [];

            // Create a pool of possible unique frequencies (e.g., 1 to 15)
            let possibleFrequencies = Array.from({ length: 15 }, (_, i) => i + 1);
            shuffleArray(possibleFrequencies);

            for (let i = 0; i < numberOfClasses; i++) {
                const startLimit = firstClassStart + (i * classWidth);
                const endLimit = startLimit + classWidth;
                const label = `${startLimit} up to ${endLimit}`;
                
                // Pick a unique frequency from the shuffled pool
                const correctFrequency = possibleFrequencies.pop(); // Get and remove the last element

                newData.push({
                    label: label,
                    start: startLimit,
                    end: endLimit,
                    midpoint: startLimit + (classWidth / 2), // Calculate midpoint for polygon
                    correctFrequency: correctFrequency,
                    currentFrequency: 0,
                    status: 'neutral'
                });
            }

            // Assign newData to histogramData immediately for question generation
            histogramData = newData;

            // --- Prepare Q2 options ---
            let maxFreq = -1;
            let mostStudentsIntervalLabel = '';
            // Find the interval with the highest frequency
            histogramData.forEach(data => {
                if (data.correctFrequency > maxFreq) {
                    maxFreq = data.correctFrequency;
                    mostStudentsIntervalLabel = data.label;
                }
            });
            questionsData.q2.correctAnswer = mostStudentsIntervalLabel;
            questionsData.q2.options = [mostStudentsIntervalLabel]; // Add correct answer first
            
            // Collect other interval labels for distractors
            let distinctDistractors = new Set();
            histogramData.filter(d => d.label !== mostStudentsIntervalLabel).forEach(d => distinctDistractors.add(d.label));

            // Add distractors until we have 4 options
            while (questionsData.q2.options.length < 4) {
                if (distinctDistractors.size > 0) {
                    const distractorToAdd = distinctDistractors.values().next().value;
                    questionsData.q2.options.push(distractorToAdd);
                    distinctDistractors.delete(distractorToAdd); // Remove to avoid duplicates
                } else {
                    // Fallback: If not enough distinct intervals, create generic ones
                    let genericDistractor = `Another interval ${Math.floor(Math.random() * 100)}`;
                    if (!questionsData.q2.options.includes(genericDistractor)) {
                        questionsData.q2.options.push(genericDistractor);
                    }
                }
            }
            questionsData.q2.options = shuffleArray(questionsData.q2.options); // Shuffle the options


            // --- Prepare Q3 options ---
            let validQ3TargetIntervals = histogramData.slice(0, histogramData.length - 1);
            let q3TargetScoreVal;
            if (validQ3TargetIntervals.length > 0) {
                q3TargetScoreVal = validQ3TargetIntervals[Math.floor(Math.random() * validQ3TargetIntervals.length)].end;
            } else {
                q3TargetScoreVal = histogramData[0].end;
            }
            questionsData.q3.targetScore = q3TargetScoreVal;
            questionsData.q3.question = `How many months had sales revenue less than <span class="icon-saudi_riyal"></span> <span id="q3Score"></span> thousand ?`;
            let q3CorrectAnswer = 0;
            histogramData.forEach(data => {
                if (data.end <= q3TargetScoreVal) {
                    q3CorrectAnswer += data.correctFrequency;
                }
            });
            questionsData.q3.correctAnswer = q3CorrectAnswer;
            questionsData.q3.options = [q3CorrectAnswer];
            while (questionsData.q3.options.length < 4) { // Change to 4 options
                let distractor = generateNumericalDistractor(q3CorrectAnswer, 3, questionsData.q3.options);
                questionsData.q3.options.push(distractor);
            }
            questionsData.q3.options = shuffleArray(questionsData.q3.options);

            // --- Prepare Q4 options ---
            let validQ4TargetIntervals = histogramData.slice(1);
            let q4TargetScoreVal;
            if (validQ4TargetIntervals.length > 0) {
                q4TargetScoreVal = validQ4TargetIntervals[Math.floor(Math.random() * validQ4TargetIntervals.length)].start;
            } else {
                q4TargetScoreVal = histogramData[0].start;
            }
            questionsData.q4.targetScore = q4TargetScoreVal;
            questionsData.q4.question = `How many months had sales revenue of at least <span class="icon-saudi_riyal"></span> <span id="q4Score"></span> thousand ?`;
            let q4CorrectAnswer = 0;
            histogramData.forEach(data => {
                if (data.start >= q4TargetScoreVal) {
                    q4CorrectAnswer += data.correctFrequency;
                }
            });
            questionsData.q4.correctAnswer = q4CorrectAnswer;
            questionsData.q4.options = [q4CorrectAnswer];
            while (questionsData.q4.options.length < 4) {
                let distractor = generateNumericalDistractor(q4CorrectAnswer, 3, questionsData.q4.options);
                questionsData.q4.options.push(distractor);
            }
            questionsData.q4.options = shuffleArray(questionsData.q4.options);

            // --- Prepare Q5 options ---
            let q5TargetIntervalIndexVal = Math.floor(Math.random() * histogramData.length);
            questionsData.q5.targetIntervalLabel = histogramData[q5TargetIntervalIndexVal].label;
            questionsData.q5.question = `What is the percentage of months with sales revenue in the interval ${questionsData.q5.targetIntervalLabel} (in thousands of <span class="icon-saudi_riyal"></span>)?`;
            let totalStudents = histogramData.reduce((sum, data) => sum + data.correctFrequency, 0);
            let targetIntervalFreq = histogramData[q5TargetIntervalIndexVal].correctFrequency;
            let q5CorrectAnswerPercentage = (totalStudents > 0) ? parseFloat(((targetIntervalFreq / totalStudents) * 100).toFixed(2)) : 0;
            questionsData.q5.correctAnswer = q5CorrectAnswerPercentage;
            questionsData.q5.options = [q5CorrectAnswerPercentage];
            while (questionsData.q5.options.length < 4) {
                let distractor = generatePercentageDistractor(q5CorrectAnswerPercentage, questionsData.q5.options);
                questionsData.q5.options.push(distractor);
            }
            questionsData.q5.options = shuffleArray(questionsData.q5.options);

            return newData;
        }

        /**
         * Populates the HTML table with the generated frequency polygon data.
         */
        function updateTable() {
            dataTableBody.innerHTML = ''; // Clear existing rows
            histogramData.forEach(data => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${data.label}</td>
                    <td>${data.correctFrequency}</td>
                `;
                dataTableBody.appendChild(row);
            });
        }

        /**
         * Draws the frequency polygon on the canvas.
         */
        function drawFrequencyPolygon() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;

            // X-axis
            ctx.beginPath();
            ctx.moveTo(padding.left, canvas.height - padding.bottom);
            ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
            ctx.stroke();

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, canvas.height - padding.bottom);
            ctx.stroke();

            // Draw Y-axis labels (Frequency)
            ctx.fillStyle = '#555';
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= maxFrequency; i += 1) {
                const y = canvas.height - padding.bottom - (i * frequencyScale);
                ctx.fillText(i, padding.left - 10, y + 5);
                // Draw grid lines
                ctx.beginPath();
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 0.5;
                ctx.moveTo(padding.left, y);
                ctx.lineTo(canvas.width - padding.right, y);
                ctx.stroke();
            }
            ctx.save();
            ctx.translate(padding.left - 45, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Frequency', 0, 0);
            ctx.restore();

            // Draw X-axis labels (Class Boundaries including virtual ones)
            const classWidth = histogramData[0].end - histogramData[0].start;
            const allBoundaryValues = [];
            
            // Add the start boundary of the virtual interval before the first
            allBoundaryValues.push(histogramData[0].start - classWidth); 
            
            // Add all actual class boundaries
            histogramData.forEach(data => {
                allBoundaryValues.push(data.start);
                allBoundaryValues.push(data.end);
            });
            // Add the end boundary of the virtual interval after the last
            allBoundaryValues.push(histogramData[histogramData.length - 1].end + classWidth);

            // Ensure unique sorted boundaries
            const uniqueSortedBoundaries = Array.from(new Set(allBoundaryValues)).sort((a, b) => a - b);

            ctx.fillStyle = '#555';
            ctx.font = '14px Arial'; /* Default font for numbers */
            
            // Calculate the starting X pixel for the first boundary label
            // The first label (uniqueSortedBoundaries[0]) corresponds to padding.left
            // Each subsequent boundary is `intervalPixelWidth` pixels away
            
            uniqueSortedBoundaries.forEach((value, i) => {
                // xPosition for boundary labels and ticks
                const xPosition = padding.left + (i * intervalPixelWidth);

                // Adjust alignment for the very first and very last labels to prevent overflow
                if (i === 0) {
                    ctx.textAlign = 'left';
                } else if (i === uniqueSortedBoundaries.length - 1) {
                    ctx.textAlign = 'right';
                } else {
                    ctx.textAlign = 'center';
                }
                ctx.fillText(value, xPosition, canvas.height - padding.bottom + 25);

                // Add the tick mark
                ctx.beginPath();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.moveTo(xPosition, canvas.height - padding.bottom);
                ctx.lineTo(xPosition, canvas.height - padding.bottom + 5); // Extend 5px below axis
                ctx.stroke();
            });
            ctx.textAlign = 'center'; // Reset for the main X-axis title
            // For canvas, we'll just use the descriptive text as custom font symbols via CSS pseudo-elements don't render directly.
            ctx.font = '14px Arial, sans-serif'; 
            ctx.fillText('Sales Revenue (in thousands)', canvas.width / 2, canvas.height - 10);


            // Prepare points for the polygon, including start and end at 0 frequency
            const polygonPoints = [];
            
            // Add initial point at 0 frequency, one interval before the first
            polygonPoints.push({
                x: padding.left + (0.5 * intervalPixelWidth), // Midpoint of the first virtual interval
                y: canvas.height - padding.bottom,
                isVirtual: true
            });

            histogramData.forEach((data, index) => {
                const x = padding.left + ((index + 1) * intervalPixelWidth) + (0.5 * intervalPixelWidth); // Midpoint of the actual data interval
                const y = canvas.height - padding.bottom - (data.currentFrequency * frequencyScale);
                polygonPoints.push({
                    x: x,
                    y: y,
                    dataIndex: index, // Store original data index for dragging
                    status: data.status // Pass status for coloring points
                });
            });

            // Add final point at 0 frequency, one interval after the last
            polygonPoints.push({
                x: padding.left + ((histogramData.length + 1) * intervalPixelWidth) + (0.5 * intervalPixelWidth), // Midpoint of the last virtual interval
                y: canvas.height - padding.bottom,
                isVirtual: true
            });

            // Draw the polygon lines
            ctx.beginPath();
            ctx.strokeStyle = '#6366f1'; // Polygon line color
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round'; // Smooth corners
            ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
            polygonPoints.forEach(point => {
                ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();

            // Draw draggable points and their frequencies
            polygonPoints.forEach((point, index) => {
                // Only draw circles for actual data points, not virtual 0-frequency points
                if (!point.isVirtual) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);

                    if (point.status === 'correct') {
                        ctx.fillStyle = '#4CAF50'; // Green for correct
                    } else if (point.status === 'incorrect') {
                        ctx.fillStyle = '#F44336'; // Red for incorrect
                    } else {
                        ctx.fillStyle = '#0084BD'; // Blue for neutral/draggable
                    }
                    
                    // Highlight hovered point
                    if (index === hoveredPointIndex) {
                        ctx.strokeStyle = '#FFD700'; // Gold border for hover
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    ctx.fill();
                    ctx.closePath();

                    // Draw frequency text above the point
                    if (histogramData[point.dataIndex].currentFrequency > 0) {
                        ctx.fillStyle = '#333';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(histogramData[point.dataIndex].currentFrequency, point.x, point.y - pointRadius - 5);
                    }
                }
            });
        }

        // Helper to get mouse/touch coordinates relative to canvas,
        // correctly scaling for a responsive canvas.
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Event handler for mouse/touch down
        function handleMouseDown(event) {
            event.preventDefault();
            const mousePos = getMousePos(event);
            
            // Check if a point is being dragged
            // Iterate through actual data points only (not virtual start/end points)
            histogramData.forEach((data, index) => {
                // x_mid needs to use the correct intervalPixelWidth and index offset
                const x_mid = padding.left + ((index + 1) * intervalPixelWidth) + (0.5 * intervalPixelWidth);
                const y_point = canvas.height - padding.bottom - (data.currentFrequency * frequencyScale);
                
                // Calculate distance from mouse to the center of the point
                const distance = Math.sqrt(
                    Math.pow(mousePos.x - x_mid, 2) + Math.pow(mousePos.y - y_point, 2)
                );

                if (distance <= dragTolerance) { // Check if within draggable radius
                    isDragging = true;
                    draggedPointIndex = index; // Store index of the actual data point
                    canvas.style.cursor = 'ns-resize'; 
                }
            });
        }

        // Event handler for mouse/touch move and cursor change on hover
        function handleMouseMove(event) {
            const mousePos = getMousePos(event);

            if (isDragging) {
                event.preventDefault();
                // Calculate new frequency based on mouse Y position
                const newY = Math.max(padding.top, Math.min(mousePos.y, canvas.height - padding.bottom));
                const newFrequency = Math.round((canvas.height - padding.bottom - newY) / frequencyScale);

                // Update current frequency, clamped between 0 and maxFrequency
                histogramData[draggedPointIndex].currentFrequency = Math.max(0, Math.min(newFrequency, maxFrequency));
                histogramData[draggedPointIndex].status = 'neutral'; // Reset status on drag
                messageBox.style.display = 'none';
                drawFrequencyPolygon();
            } else {
                let currentHoveredIndex = -1;
                histogramData.forEach((data, index) => {
                    // x_mid needs to use the correct intervalPixelWidth and index offset
                    const x_mid = padding.left + ((index + 1) * intervalPixelWidth) + (0.5 * intervalPixelWidth);
                    const y_point = canvas.height - padding.bottom - (data.currentFrequency * frequencyScale);

                    const distance = Math.sqrt(
                        Math.pow(mousePos.x - x_mid, 2) + Math.pow(mousePos.y - y_point, 2)
                    );
                    if (distance <= dragTolerance) {
                        currentHoveredIndex = index;
                    }
                });

                // Update hoveredPointIndex and redraw only if it changed
                if (hoveredPointIndex !== currentHoveredIndex) {
                    hoveredPointIndex = currentHoveredIndex;
                    canvas.style.cursor = (hoveredPointIndex !== -1) ? 'ns-resize' : 'default';
                    drawFrequencyPolygon(); // Redraw to show hover effect
                }
            }
        }

        // Event handler for mouse/touch up
        function handleMouseUp() {
            if (!isDragging) return; 
            isDragging = false;
            draggedPointIndex = -1;
            // No need to reset cursor here, it's handled by mousemove's else block
        }

        // Function to check the user's work for the frequency polygon (Q1)
        function checkFrequencyPolygonWork() {
            let allCorrect = true;
            histogramData.forEach(data => {
                if (data.currentFrequency === data.correctFrequency) {
                    data.status = 'correct';
                } else {
                    data.status = 'incorrect';
                    allCorrect = false;
                }
            });
            drawFrequencyPolygon();

            if (allCorrect) {
                showMessage('Congratulations! Your frequency polygon is correct!', 'success');
            } else {
                showMessage('Some points are incorrect. Keep trying!', 'error');
            }
        }

        // Function to render a single multiple-choice question
        function renderQuestion(questionId) {
            const questionData = questionsData[questionId];
            const optionsGroup = document.getElementById(`${questionId}Options`);
            optionsGroup.innerHTML = ''; // Clear previous options

            questionData.options.forEach((option, index) => {
                const optionChar = String.fromCharCode(65 + index); // A, B, C, D
                const optionDiv = document.createElement('div');
                optionDiv.className = 'flex items-center mb-2';
                optionDiv.innerHTML = `
                    <input type="radio" id="${questionId}Option${optionChar}" name="${questionId}" value="${option}" class="mr-2">
                    <label for="${questionId}Option${optionChar}">${optionChar}: ${option}</label>
                `;
                optionsGroup.appendChild(optionDiv);
            });

            // Update question text for dynamic questions
            if (questionId === 'q3') {
                document.getElementById('q3Score').innerHTML = questionData.targetScore;
            } else if (questionId === 'q4') {
                document.getElementById('q4Score').innerHTML = questionData.targetScore;
            } else if (questionId === 'q5') {
                document.getElementById('q5Interval').innerHTML = questionData.targetIntervalLabel;
            }
        }

        // Function to check a single multiple-choice question
        function checkQuestion(questionId) {
            const questionData = questionsData[questionId];
            const selectedOption = document.querySelector(`input[name="${questionId}"]:checked`);
            const feedbackElement = document.getElementById(`${questionId}Feedback`);

            if (!selectedOption) {
                feedbackElement.textContent = 'Please select an option.';
                feedbackElement.className = 'answer-feedback text-yellow-600';
                return;
            }

            const userAnswer = selectedOption.value; // Get the raw value (string or number as string)

            let isCorrect = false;
            if (typeof questionData.correctAnswer === 'number') {
                // For numerical answers, parse the user's answer to a float and compare with tolerance
                const parsedUserAnswer = parseFloat(userAnswer);
                isCorrect = Math.abs(parsedUserAnswer - questionData.correctAnswer) < 0.01;
            } else {
                // For string answers (like Q2), perform a direct string comparison
                isCorrect = userAnswer === questionData.correctAnswer;
            }

            if (isCorrect) {
                feedbackElement.textContent = 'Correct!';
                feedbackElement.className = 'answer-feedback text-green-600';
            } else {
                feedbackElement.textContent = `Incorrect. The correct answer is: ${questionData.correctAnswer}`;
                feedbackElement.className = 'answer-feedback text-red-600';
            }
        }

        // Function to reset the frequency polygon and questions
        function resetHistogram() {
            histogramData.forEach(data => {
                data.currentFrequency = 0;
                data.status = 'neutral';
            });
            showMessage('', 'neutral');
            drawFrequencyPolygon();
            
            // Clear question feedback and uncheck radio buttons
            document.querySelectorAll('.answer-feedback').forEach(el => {
                el.textContent = '';
                el.className = 'answer-feedback'; // Reset class
            });
            document.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = false);

            // Re-generate and render questions for new values
            histogramData = generateRandomData(); // Generate new data for frequency polygon and questions
            updateTable(); // Update table with new data
            renderQuestion('q2');
            renderQuestion('q3');
            renderQuestion('q4');
            renderQuestion('q5');
        }

        // Function to display messages
        function showMessage(message, type) {
            messageBox.textContent = message;
            messageBox.className = `message-box ${type}`;
            messageBox.style.display = message ? 'block' : 'none';
        }

        // This function now correctly recalculates all necessary canvas dimensions
        // and red-draws the frequency polygon.
        function resizeCanvas() {
            const containerWidth = canvas.parentElement.clientWidth;
            const aspectRatio = 700 / 400; // Maintain a 7:4 aspect ratio
            canvas.width = containerWidth > 900 ? 900 - 60 : containerWidth;
            canvas.height = canvas.width / aspectRatio;

            // Recalculate all dimensions based on the new canvas size
            plotAreaWidth = canvas.width - padding.left - padding.right;
            plotAreaHeight = canvas.height - padding.top - padding.bottom;
            // The width of one interval on the plot, considering the two virtual intervals
            const totalIntervalsOnPlot = histogramData.length + 2;
            intervalPixelWidth = plotAreaWidth / totalIntervalsOnPlot; // New variable

            maxFrequency = Math.max(...histogramData.map(d => d.correctFrequency)) + 2;
            frequencyScale = plotAreaHeight / maxFrequency;

            drawFrequencyPolygon();
        }

        // Initial setup and event listeners
        document.addEventListener('DOMContentLoaded', () => {
            histogramData = generateRandomData(); // Generate data first
            updateTable(); // Populate table with data
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial call to resize and draw the canvas

            // Render all multiple-choice questions
            renderQuestion('q2');
            renderQuestion('q3');
            renderQuestion('q4');
            renderQuestion('q5');

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleMouseDown);
            canvas.addEventListener('touchmove', handleMouseMove);
            canvas.addEventListener('touchend', handleMouseUp);

            document.getElementById('checkButton').addEventListener('click', checkFrequencyPolygonWork); // Checks frequency polygon
            document.getElementById('resetButton').addEventListener('click', resetHistogram);

            // Add event listeners for new "Check Answer" buttons
            document.querySelectorAll('.check-question-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const questionId = event.target.dataset.question;
                    checkQuestion(questionId);
                });
            });
        });

        // Fallback for window.onload to ensure resizeCanvas is called again
        window.addEventListener('load', resizeCanvas);
    </script>
</body>
</html>
